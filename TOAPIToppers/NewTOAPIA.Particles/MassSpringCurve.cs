

namespace NewTOAPIA.Modeling.Particles
{
    using System;
    using System.Collections.Generic;
    using System.Text;

    using Real = System.Single;
    
    // Construction and destruction.  This class represents a set of N-1
    // springs connecting N masses that lie on a curve.  Spring i connects
    // masses i-1 and i for 1 <= i <= N-1.
    public class MassSpringCurve : ParticleSystem
    {
        int m_iNumSprings;
        Real[] m_afConstant;
        Real[] m_afLength;
        //    protected using ParticleSystem<Real,TVector>::m_iNumParticles;
        //protected using ParticleSystem<Real,TVector>::m_afInvMass;

        public MassSpringCurve(int iNumParticles, Real fStep)
            : base(iNumParticles, fStep)
        {
            m_iNumSprings = NumParticles - 1;
            m_afConstant = new Real[m_iNumSprings];
            m_afLength = new Real[m_iNumSprings];
        }

        ~MassSpringCurve()
        {
        }

        public int NumSprings
        {
            get { return m_iNumSprings; }
        }

        public Real Constant(int i)  // spring constant
        {
            return m_afConstant[i];
        }

        public Real Length(int i)  // spring resting length
        {
            return m_afLength[i];
        }

        public override void Render(NewTOAPIA.GL.GraphicsInterface gi)
        {
            throw new NotImplementedException();
        }

        protected override void InitializeParticle(int index)
        {
            throw new NotImplementedException();
        }

        // Callback for acceleration 
        // (ODE solver uses x" = F/m) applied to particle i.  
        // The positions and velocities are not necessarily
        // m_akPosition and m_akVelocity since the ODE solver evaluates the
        // impulse function at intermediate positions.
        protected override float3 Acceleration(int i, Real fTime, float3[] akPosition, float3[] akVelocity)
        {
            // Compute spring forces on position X[i].  The positions are not
            // necessarily m_akPosition since the RK4 solver in ParticleSystem
            // evaluates the acceleration function at intermediate positions.  The end
            // points of the curve of masses must be handled separately since each
            // has only one spring attached to it.

            float3 kAcceleration = ExternalAcceleration(i, fTime, akPosition, akVelocity);

            float3 kDiff, kForce;
            Real fRatio;

            if (i > 0)
            {
                int iM1 = i - 1;
                kDiff = akPosition[iM1] - akPosition[i];
                fRatio = m_afLength[iM1] / kDiff.Length;
                kForce = m_afConstant[iM1] * (((Real)1.0) - fRatio) * kDiff;
                kAcceleration += MassInverse[i] * kForce;
            }

            int iP1 = i + 1;
            if (iP1 < NumParticles)
            {
                kDiff = akPosition[iP1] - akPosition[i];
                fRatio = m_afLength[i] / kDiff.Length;
                kForce = m_afConstant[i] * (((Real)1.0) - fRatio) * kDiff;
                kAcceleration += MassInverse[i] * kForce;
            }

            return kAcceleration;
        }

        /// <summary>
        /// The default external force is zero.
        /// 
        /// To provide nonzero external forces, a subclass can override this method
        /// and supply forces such as gravity, wind, friction, and the like.
        /// 
        /// This function is called from the Acceleration()... method, to append
        /// the acceleration F/m generated by the external force F.
        /// </summary>
        /// <param name="i"></param>
        /// <param name="fTime"></param>
        /// <param name="akPosition"></param>
        /// <param name="akVelocity"></param>
        /// <returns></returns>
        public virtual float3 ExternalAcceleration(int i, Real fTime, float3[] akPosition, float3[] akVelocity)
        {
            return float3.Zero;
        }
    }
}
